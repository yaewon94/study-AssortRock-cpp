// 메모리 영역
//
// 1. 스택영역 : 함수, 지역변수
// * first in last out 구조
// * 할당 : 함수가 호출된 시점
// * 제거 : 함수 호출이 종료될 때
// * 호출규칙
//		__cdecl (반환값을 리턴하고, 호출자에 의해 스택 제거)
//		__stdcall (반환값을 레지스터 메모리에 저장한 뒤, 함수 스스로 스택을 제거하고, 레지스터 메모리에 저장된 값 리턴)
// * 함수 내부의 명령어는 ROM에 저장되는거지, 스택에 저장되는게 아님
// * 스택의 크기는 제한적이므로, 스택이 너무 많이 쌓이면 스택 오버플로우 발생함
// * 다른 함수의 지역변수에는 접근 불가능 (포인터 제외)
// 
// 2. 데이터 영역 : 전역변수, 정적변수(static), 외부변수(extern)
// * 프로그램 시작 시 초기화, 종료 시 해제
//
// 3. 힙 영역 : 동적할당
// * 런타임 중에 실시간으로 필요한 메모리를 할당받거나 해제하는 작업
// * 할당받은 메모리를 프로그래머가 반드시 해제해야 함
// * 메모리를 해제하지 않으면, 그 메모리 영역이 사용중인 상태로 남게 됨 (메모리 누수 => 누적되면 RAM이 모자라게 됨)
// * 문자열의 끝을 알려주는 널문자(\0) 처럼, 할당받은 메모리 영역의 끝을 알려주는 마킹 비트 존재
// * 할당받은 메모리 영역을 초과한 곳에 접근한 경우 : 언제 런타임에러가 터질지 모름
// 
// 4. ROM(Read Only Memory) : 코드 및 초기화 데이터(ex. const 리터럴(123), 문자열 리터럴("hello"))
//

#include "FunctionTest.h"
#include "ValueTest.h"
#include <iostream>

// 전역변수
int global = 0;

// (함수 외부에서 선언된) 정적변수 : 선언된 파일에서만 사용 가능
// ex. FunctionTest.cpp 의 s_global 와 다른 변수 취급 
static int s_global = 0;

// (ValueTest.h 에 선언된) 외부변수 구현
// 반드시 값 구현을 해야 사용 가능
int e_global = 10;

int Test1()
{
	// (함수 내부에서 선언된) 정적변수 : 선언된 함수 내부에서만 사용 가능
	// 함수 종료와 관계없이 프로그램 실행동안 데이터 영역 메모리에 계속 유지됨
	static int s = 0; // 최초 1회만 초기화
	
	return ++s;
}

class DynamicAssignTest
{

};

int main()
{
	// 모든 함수에서 전역변수에 접근 가능 (보안 취약)
	global++;

	// main() 내의 지역변수
	int i = 0;

	Test1();
	Test1();
	Test1();

	Test2();

	// 구현된 외부변수 사용
	e_global = 100;

	//
	// 메모리 동적할당
	// 1. void* malloc(size_t size), free(void*)
	// 반환타입 void* : 프로그래머가 원하는 타입의 포인터로 캐스팅하여 사용하는 용도
	// 아래의 경우는 20 byte를 할당받아 int 타입으로 캐스팅 했으므로, int 타입 5칸을 할당받은 것
	// 재할당 받는 경우, 기존에 할당받은 공간 뒤에 받는 것이 아니라 새로운 곳에 메모리 할당을 받게 됨
	int* ptr1 = (int*)malloc(20);
	ptr1[0] = 0;
	//ptr1[5] = 100;	// 할당받은 20 byte 공간을 초과한 곳에 접근(컴파일에러가 뜨지 않기 때문에 답이 없는것) : 다른 작업을 하다가 런타임에러를 일으키는 원인
	free(ptr1);			// 할당받은 메모리 해제
	//
	// 2. new, delete
	// 템플릿처럼 동작
	// malloc 은 사용하려는 클래스의 생성자를 자동으로 호출해주지 않음
	// => new 를 사용하면 동적 메모리 할당, 생성자 호출까지 해줌
	// => delete 를 사용하면 new로 할당받은 소멸자를 호출하고 메모리를 해제해준다
	DynamicAssignTest* dat = new DynamicAssignTest;
	delete dat;
	//
	// 3. new[], delete[]
	// 연속된 공간에 동적할당
	int* arr = new int[5] {};
	arr[2] = 2;	// 인덱스로 접근 가능
	//delete arr;	// new[] 로 할당받은 것을 delete로 하면 배열의 첫번째 메모리만 해제됨
	delete[] arr;

	return 0;
}
